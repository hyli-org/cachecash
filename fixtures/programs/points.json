{"noir_version":"1.0.0-beta.9+6abff2f16e1c1314ba30708d1cf032a536de3d19","hash":"18385977757983768669","abi":{"parameters":[{"name":"notes","type":{"kind":"array","length":10,"type":{"kind":"struct","path":"common::Note","fields":[{"name":"kind","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}},{"name":"address","type":{"kind":"field"}},{"name":"psi","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"secret_keys","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"address","type":{"kind":"field"},"visibility":"private"},{"name":"timestamp","type":{"kind":"field"},"visibility":"public"},{"name":"value","type":{"kind":"field"},"visibility":"public"},{"name":"hash","type":{"kind":"field"},"visibility":"public"},{"name":"commitments","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"public"}],"return_type":null,"error_types":{"1714809443410094063":{"error_kind":"string","string":"Padding notes must be zero value"},"3898381286344942305":{"error_kind":"string","string":"Input note is not owned by the owner"},"6661914514907183551":{"error_kind":"string","string":"Note commitment is not valid"},"12506305391274039017":{"error_kind":"string","string":"Invalid value"}}},"bytecode":"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","debug_symbols":"pZjdbuJADIXfJddcjO3x/OyrrFYVbdMKCdGKwkqrqu++E3wM5SJRmtzUhtQefye2gXx2z/3j+fVhd3h5++h+/f7sHo+7/X73+rB/e9qedm+H9u7n16bzlw+nY9+3t7pv11vU+/bYH07dr8N5v990f7f78+WfPt63h4s9bY/tath0/eG52ZbwZbfvB+9rc4sO46GSFcFS5Bqe4tz4SH545LgkXsnjky6JzwnxSmEsPo7H840/3OKV7+L1p/w/iI/i8VoWxCsXxKcWNBJfJu6/sp9P6RZf7+LrhH5cKhKwBB7LQBO3kCR4ChIuoyloPEWNfherLkpAgV0HCt8acVkNWRfpQOlaAxVdcjNS8W7kVGW0iLT+ZuTVWk5xZPKp5ixhtIiJFJSzDxblOtqXHNY21VQN9aZl5dEa5m0nGt0uYWo7eD9oLmPbkScKKOK3soyvp8kE1Suo4/uRJxoyk0uQE40myCs3HJfVK47r6qmStd04qUMtVx10kQ7zplJk9VRKXL1dJquYN5cz21ppyWBeWyrRkq9NaZAIH/uL4st1qiSNfm0KK6cq0uqpirz6A3Oyink9HePqno66cranEswcikmMeUMxr6fifU/+aa+2T7vj3Y+fLrSLm44uf/nyV1ropovDktx0aiaZyWaKmWqGWgpqG4toaKJmWxpuRZDARlgdGrbZBJthy/ADqNlqRVhFjJL4Ug2LncUoi1EXozDOVgMXq4GrnSkBlmDZzhSxMyUasppJZvLlTAGmgDMGWIJlOzOKnRnBGRU2wYIzgjMapxqnGqcap4JTXX5wKjgVnApOBWcCZwJnAmcCZzLOZJzJOJNxJnAmcGZwZnBmcGZwZnBmcGZwZnBmcGbjLMZZjLMYZwFnAWcBZwFnAWcBZwFnBWcFZwVnBWc1zmqc1TircVZv22vfBnfIHaBSACsFb96g7iR3vH+DN3AwYiIMFRGsQROBmii6o+4kd7JPE9CJwE4c3CF3gE8MfmITgFhhE6xpQAwRiF0FcRXEVRBXQVwFcRXEVRBXQVwFcRUEKkSoEKFChArRVYiuQnQVoqsQXYXoKkRXQV0FdRXUVVBXYRgfqYOjw8OJwWmZY/0a9uZxt33c93jy83I+PH17EHT69+5X/FHR+/HtqX8+H/thb16utU36Hw==","file_map":{"52":{"source":"use poseidon::poseidon2;\n\npub struct Note {\n    pub kind: Field,\n    pub value: Field,\n    pub address: Field,\n    pub psi: Field,\n}\n\npub struct InputNote {\n    pub note: Note,\n    pub secret_key: Field,\n}\n\npub fn check_commitment(note: Note, commitment: Field) {\n    assert(get_note_commitment(note) == commitment, \"Note commitment is not valid\");\n}\n\npub fn get_note_commitment(note: Note) -> Field {\n    if (note.kind == 0) {\n        assert(note.value == 0, \"Padding notes must be zero value\");\n        0\n    } else {\n        poseidon2::Poseidon2::hash(\n            [0x2, note.kind, note.value, note.address, note.psi, 0, 0],\n            7,\n        )\n    }\n}\n\npub fn get_address(secret_key: Field) -> Field {\n    poseidon2::Poseidon2::hash([secret_key, 0], 2)\n}\n\npub fn check_input_note_ownership(input_note: InputNote) {\n    if (input_note.note.value != 0) {\n        assert(\n            get_address(input_note.secret_key) == input_note.note.address,\n            \"Input note is not owned by the owner\",\n        );\n    }\n}\n\npub fn slice<let N: u32, let L: u32>(bytes: [u8; N], start: u32) -> [u8; L] {\n    let end = start + L;\n    assert(end <= N, \"slice: slice end out of bounds\");\n    let mut result = [bytes[0]; L];\n    for i in 0..L {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        as_field += (bytes[i] as Field) * offset;\n        offset *= 256;\n    }\n    as_field\n}\n\npub fn is_one_of(value: Field, one_of: [Field]) -> bool {\n    let mut is_one_of = false;\n    for possible in one_of {\n        if possible == value {\n            is_one_of = true;\n        }\n    }\n    is_one_of\n}\n","path":"/Users/calummoore/conductor/repo/zk-rollup/calummoore-petra/noir/common/src/lib.nr"},"59":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/calummoore/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"64":{"source":"use common::{check_commitment, check_input_note_ownership, get_address, InputNote, Note};\nuse poseidon::poseidon2;\n\nfn main(\n    notes: [Note; 10],\n    secret_keys: [Field; 10],\n    address: Field,\n    timestamp: pub Field,\n    value: pub Field,\n    hash: pub Field,\n    commitments: pub [Field; 10],\n) {\n    let mut notes_value = 0;\n\n    for i in 0..10 {\n        let note = notes[i];\n        let secret_key = secret_keys[i];\n        let commitment = commitments[i];\n\n        check_commitment(note, commitment);\n        check_input_note_ownership(InputNote { note, secret_key });\n\n        notes_value += note.value;\n    }\n\n    assert(value == notes_value, \"Invalid value\");\n    assert(poseidon2::Poseidon2::hash([timestamp, address], 2) == hash);\n}\n\n#[test]\nfn test_main() {\n    let pk = 101;\n    let address = get_address(pk);\n\n    // Create 10 notes with the same address\n    let mut notes: [Note; 10] = [\n        Note { kind: 0, value: 0, address: 0, psi: 0 },\n        Note { kind: 1, value: 20, address: address, psi: 2 },\n        Note { kind: 1, value: 30, address: address, psi: 3 },\n        Note { kind: 1, value: 40, address: address, psi: 4 },\n        Note { kind: 1, value: 50, address: address, psi: 5 },\n        Note { kind: 1, value: 60, address: address, psi: 6 },\n        Note { kind: 1, value: 70, address: address, psi: 7 },\n        Note { kind: 1, value: 80, address: address, psi: 8 },\n        Note { kind: 1, value: 90, address: address, psi: 9 },\n        Note { kind: 1, value: 100, address: address, psi: 10 },\n    ];\n\n    // Calculate the total value of all notes\n    let total_value = 540;\n\n    // Create an array of secret keys (all the same in this test)\n    let mut secret_keys = [pk; 10];\n    secret_keys[0] = 0;\n\n    // Calculate commitments for each note\n    let mut commitments: [Field; 10] = [0; 10];\n    for i in 0..10 {\n        commitments[i] = common::get_note_commitment(notes[i]);\n    }\n\n    // Create timestamp and calculate hash\n    let timestamp = 10000000;\n    let message_hash = poseidon2::Poseidon2::hash([timestamp, address], 2);\n\n    main(\n        notes,\n        secret_keys,\n        address,\n        timestamp,\n        total_value,\n        message_hash,\n        commitments,\n    )\n}\n","path":"/Users/calummoore/conductor/repo/zk-rollup/calummoore-petra/noir/points/src/main.nr"}},"names":["main"],"brillig_names":["directive_invert"]}