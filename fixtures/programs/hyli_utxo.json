{"noir_version":"1.0.0-beta.14+60ccd48e18ad8ce50d5ecda9baf813b712145051","hash":"10570404272837064354","abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":256},"visibility":"public"},{"name":"tx_hash","type":{"kind":"string","length":64},"visibility":"public"},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_number","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_contract_name_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"blob_contract_name","type":{"kind":"string","length":256},"visibility":"public"},{"name":"blob_capacity","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob","type":{"kind":"array","length":128,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"tx_blob_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"success","type":{"kind":"boolean"},"visibility":"public"},{"name":"input_notes","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"common::InputNote","fields":[{"name":"note","type":{"kind":"struct","path":"common::Note","fields":[{"name":"kind","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}},{"name":"address","type":{"kind":"field"}},{"name":"psi","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"output_notes","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"common::Note","fields":[{"name":"kind","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}},{"name":"address","type":{"kind":"field"}},{"name":"psi","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"pmessage4","type":{"kind":"field"},"visibility":"private"},{"name":"commitments","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},{"name":"messages","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"public"}],"return_type":null,"error_types":{"305982299587252521":{"error_kind":"string","string":"next_state must be 4 bytes"},"899926670791728076":{"error_kind":"string","string":"blob index must align with invocation index"},"1434402537454335388":{"error_kind":"string","string":"Burn hash must match message"},"1622262757561716190":{"error_kind":"string","string":"blob contract name must be 9 bytes"},"2212929835929732210":{"error_kind":"string","string":"Mint hash must match message"},"2402221729226865771":{"error_kind":"string","string":"messages[4] must match private input"},"2591464926340063308":{"error_kind":"string","string":"Burn output must match value message"},"3088914507699214238":{"error_kind":"string","string":"Invalid kind"},"6000943134446254388":{"error_kind":"string","string":"identity length overflow"},"7126743292872256338":{"error_kind":"string","string":"Padding notes must be zero value"},"7926997804325803954":{"error_kind":"string","string":"Input and output totals do not match"},"8990736325391075029":{"error_kind":"string","string":"blob length must be 128 bytes"},"9333812033455989394":{"error_kind":"string","string":"Burn note kind must match message"},"9417684495172465781":{"error_kind":"string","string":"initial_state must be 4 bytes"},"10045219216956375247":{"error_kind":"string","string":"Mint output must match value message"},"10619113442490094159":{"error_kind":"string","string":"Mint note kind must match message"},"10877600279739873440":{"error_kind":"string","string":"contract execution must succeed"},"11305677572723109408":{"error_kind":"string","string":"Inconsistent kinds are not allowed"},"11866551368962569294":{"error_kind":"string","string":"transaction must provide enough blobs"},"12382400539224138144":{"error_kind":"string","string":"Input note is not owned by the owner"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"13470221555765370842":{"error_kind":"string","string":"unsupported Hyli output version"},"13636837564303549960":{"error_kind":"string","string":"blob capacity must be 128 bytes"},"15835548349546956319":{"error_kind":"string","string":"Field failed to decompose into specified 32 limbs"},"15962527438820422329":{"error_kind":"string","string":"exactly one blob is expected"},"16206851307168770777":{"error_kind":"string","string":"blob must match concatenated commitments"},"16398460003478624606":{"error_kind":"string","string":"Note commitment is not valid"}}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"use common::{check_commitment, check_input_note_ownership, InputNote, Note};\nuse poseidon::poseidon2;\nuse utxo_lib::utxo_main;\n\nfn field_to_bytes(value: Field) -> [u8; 32] {\n    value.to_be_bytes()\n}\n\n\nfn main(\n    // Hyli-required public plumbing\n    version: pub u32,\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    identity_len: pub u8,\n    identity: pub str<256>,\n    tx_hash: pub str<64>,\n    index: pub u32,\n    blob_number: pub u32,\n    blob_index: pub u32,\n    blob_contract_name_len: pub u8,\n    blob_contract_name: pub str<256>,\n    blob_capacity: pub u32,\n    blob_len: pub u32,\n    blob: pub [u8; 128],\n    tx_blob_count: pub u32,\n    success: pub bool,\n    // Wrapped UTXO inputs (mirrors noir/utxo)\n    input_notes: [InputNote; 2],\n    output_notes: [Note; 2],\n    pmessage4: Field,\n    commitments: pub [Field; 4],\n    messages: pub [Field; 5],\n) {\n    // ---------------------------------------------------------------------\n    // Hyli contract framing\n    // ---------------------------------------------------------------------\n    assert(success, \"contract execution must succeed\");\n    assert(version == 1, \"unsupported Hyli output version\");\n\n    assert(initial_state_len == 4, \"initial_state must be 4 bytes\");\n    assert(next_state_len == 4, \"next_state must be 4 bytes\");\n\n    assert(blob_capacity == 128, \"blob capacity must be 128 bytes\");\n    assert(blob_len == 128, \"blob length must be 128 bytes\");\n    assert(blob_number == 1, \"exactly one blob is expected\");\n    assert(tx_blob_count >= blob_number, \"transaction must provide enough blobs\");\n    assert(blob_index == index, \"blob index must align with invocation index\");\n\n    // // Basic hygiene on the identity payload so the plumbing is exercised.\n    // let identity_bytes = identity.as_bytes();\n    // assert(identity_bytes.len() == identity_len as u32, \"identity_len mismatch\");\n\n    // let tx_hash_bytes = tx_hash.as_bytes();\n    // assert(tx_hash_bytes.len() <= 64, \"tx hash too long\");\n\n    assert(identity_len as u32 <= 256, \"identity length overflow\");\n    assert(blob_contract_name_len == 9, \"blob contract name must be 9 bytes\");\n\n    let _ = initial_state;\n    let _ = next_state;\n\n\n    // ---------------------------------------------------------------------\n    // Call through to the original UTXO circuit\n    // ---------------------------------------------------------------------\n    utxo_main(\n        input_notes,\n        output_notes,\n        pmessage4,\n        commitments,\n        messages,\n    );\n\n    // Mirror key checks so the Hyli host can rely on them directly.\n    check_commitment(input_notes[0].note, commitments[0]);\n    check_commitment(input_notes[1].note, commitments[1]);\n    check_commitment(output_notes[0], commitments[2]);\n    check_commitment(output_notes[1], commitments[3]);\n\n    check_input_note_ownership(input_notes[0]);\n    check_input_note_ownership(input_notes[1]);\n\n    // ---------------------------------------------------------------------\n    // Collect nullifier commitments to expose them through the blob payload.\n    // ---------------------------------------------------------------------\n    let mut nullifier_commitments: [Field; 2] = [0; 2];\n    for i in 0..2 {\n        let note = input_notes[i];\n        let private_commitment = poseidon2::Poseidon2::hash([note.note.psi, note.secret_key], 2);\n        nullifier_commitments[i] = private_commitment;\n    }\n\n    let expected_blob = build_blob_payload(commitments, nullifier_commitments);\n    assert(blob == expected_blob, \"blob must match concatenated commitments\");\n}\n\nfn build_blob_payload(\n    commitments: [Field; 4],\n    nullifier_commitments: [Field; 2],\n) -> [u8; 128] {\n    let mut bytes: [u8; 128] = [0; 128];\n    let mut offset: u32 = 0;\n\n    for i in 0..2 {\n        let commitment_bytes = field_to_bytes(commitments[i]);\n        for j in 0..32 {\n            let j_idx: u32 = j as u32;\n            let index: u32 = offset + j_idx;\n            bytes[index] = commitment_bytes[j_idx];\n        }\n        offset += 32;\n    }\n\n    for i in 0..2 {\n        let commitment_bytes = field_to_bytes(nullifier_commitments[i]);\n        for j in 0..32 {\n            let j_idx: u32 = j as u32;\n            let index: u32 = offset + j_idx;\n            bytes[index] = commitment_bytes[j_idx];\n        }\n        offset += 32;\n    }\n\n    bytes\n}\n\n#[test]\nfn test_build_blob_payload_concatenates_commitments() {\n    let commitments: [Field; 4] = [11, 22, 33, 44];\n    let nullifiers: [Field; 2] = [55, 66];\n    let blob = build_blob_payload(commitments, nullifiers);\n    let mut expected: [u8; 128] = [0; 128];\n\n    let arrays = [\n        field_to_bytes(commitments[0]),\n        field_to_bytes(commitments[1]),\n        field_to_bytes(nullifiers[0]),\n        field_to_bytes(nullifiers[1]),\n    ];\n\n    for i in 0..4 {\n        let start = i * 32;\n        for j in 0..32 {\n            expected[start + j] = arrays[i][j];\n        }\n    }\n\n    assert(blob == expected, \"blob must match concatenated commitment bytes\");\n}\n","path":"/Users/matteo/projects/cachecash/noir/hyli_utxo/src/main.nr"},"51":{"source":"use poseidon::poseidon2;\n\npub struct Note {\n    pub kind: Field,\n    pub value: Field,\n    pub address: Field,\n    pub psi: Field,\n}\n\npub struct InputNote {\n    pub note: Note,\n    pub secret_key: Field,\n}\n\npub fn check_commitment(note: Note, commitment: Field) {\n    assert(get_note_commitment(note) == commitment, \"Note commitment is not valid\");\n}\n\npub fn get_note_commitment(note: Note) -> Field {\n    if (note.kind == 0) {\n        assert(note.value == 0, \"Padding notes must be zero value\");\n        0\n    } else {\n        poseidon2::Poseidon2::hash(\n            [0x2, note.kind, note.value, note.address, note.psi, 0, 0],\n            7,\n        )\n    }\n}\n\npub fn get_address(secret_key: Field) -> Field {\n    poseidon2::Poseidon2::hash([secret_key, 0], 2)\n}\n\npub fn check_input_note_ownership(input_note: InputNote) {\n    if (input_note.note.value != 0) {\n        assert(\n            get_address(input_note.secret_key) == input_note.note.address,\n            \"Input note is not owned by the owner\",\n        );\n    }\n}\n\npub fn slice<let N: u32, let L: u32>(bytes: [u8; N], start: u32) -> [u8; L] {\n    let end = start + L;\n    assert(end <= N, \"slice: slice end out of bounds\");\n    let mut result = [bytes[0]; L];\n    for i in 0..L {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        as_field += (bytes[i] as Field) * offset;\n        offset *= 256;\n    }\n    as_field\n}\n\npub fn is_one_of(value: Field, one_of: [Field]) -> bool {\n    let mut is_one_of = false;\n    for possible in one_of {\n        if possible == value {\n            is_one_of = true;\n        }\n    }\n    is_one_of\n}\n","path":"/Users/matteo/projects/cachecash/noir/common/src/lib.nr"},"58":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"60":{"source":"use common::{\n    check_commitment, check_input_note_ownership, get_address, get_note_commitment, InputNote, Note,\n};\nuse poseidon::poseidon2;\n\npub fn utxo_main(\n    input_notes: [InputNote; 2],\n    output_notes: [Note; 2],\n    pmessage4: Field,\n    commitments: [Field; 4],\n    messages: [Field; 5],\n) {\n    // Check the commitments\n    check_commitment(input_notes[0].note, commitments[0]);\n    check_commitment(input_notes[1].note, commitments[1]);\n    check_commitment(output_notes[0], commitments[2]);\n    check_commitment(output_notes[1], commitments[3]);\n\n    // Check individual outputs are not greater than 240 bits\n    output_notes[0].value.assert_max_bit_size::<240>();\n    output_notes[1].value.assert_max_bit_size::<240>();\n\n    let input_value = input_notes[0].note.value + input_notes[1].note.value;\n\n    let output_value = output_notes[0].value + output_notes[1].value;\n\n    // Check for multiple kinds, not currently supported in this proof\n    let (is_multiple_kinds, _note_kind) = is_multiple_kinds([\n        input_notes[0].note,\n        input_notes[1].note,\n        output_notes[0],\n        output_notes[1],\n    ]);\n    assert(!is_multiple_kinds, \"Inconsistent kinds are not allowed\");\n\n    // Kind of UTXO txn\n    let kind = messages[0];\n\n    // Messages (only for mint/burns, otherwise all zeros)\n    let msg_note_kind = messages[1];\n    let msg_value = messages[2];\n\n    // Assert message value size is max 240 bits to prevent overflow attack\n    msg_value.assert_max_bit_size::<240>();\n\n    let msg_hash = messages[3];\n    let burn_addr = messages[4];\n\n    let mint_hash = poseidon2::Poseidon2::hash([output_notes[0].psi, output_notes[1].psi], 2);\n\n    let burn_hash = commitments[0];\n\n    if (kind == 1) {\n        assert(input_value == output_value, \"Input and output totals do not match\");\n    } else if (kind == 2) {\n        assert(output_value == input_value + msg_value, \"Mint output must match value message\");\n        assert(mint_hash == msg_hash, \"Mint hash must match message\");\n        assert(output_notes[0].kind == msg_note_kind, \"Mint note kind must match message\")\n    } else if (kind == 3) {\n        assert(pmessage4 == burn_addr, \"messages[4] must match private input\");\n        assert(burn_hash == msg_hash, \"Burn hash must match message\");\n        assert(input_value == output_value + msg_value, \"Burn output must match value message\");\n        assert(input_notes[0].note.kind == msg_note_kind, \"Burn note kind must match message\")\n    } else {\n        assert(false, \"Invalid kind\");\n    }\n\n    // Check the user owns the input notes\n    check_input_note_ownership(input_notes[0]);\n    check_input_note_ownership(input_notes[1]);\n}\n\nfn is_multiple_kinds(notes: [Note; 4]) -> (bool, Field) {\n    let mut first_non_zero_kind = 0;\n    let mut is_multiple_kinds = false;\n\n    for i in 0..4 {\n        if !is_multiple_kinds {\n            if notes[i].kind != 0 {\n                if first_non_zero_kind == 0 {\n                    first_non_zero_kind = notes[i].kind;\n                } else if first_non_zero_kind != notes[i].kind {\n                    is_multiple_kinds = true;\n                }\n            }\n        }\n    }\n\n    (is_multiple_kinds, first_non_zero_kind)\n}\n\nfn bridged_note_kind() -> Field {\n    3533694129556768672311144317398675444585744224105014452550528428861358080\n}\n\n#[test]\nfn test_send_two_inputs_two_outputs() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 10, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 1, address, psi: 3 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 14, address, psi: 4 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_send_one_input_two_outputs() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 10, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 1, address, psi: 3 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 9, address, psi: 4 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_send_two_inputs_one_output() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 10, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 15, address, psi: 3 };\n    let note_4 = Note { kind: 0, value: 0, address, psi: 0 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test(should_fail)]\nfn test_send_diff_kinds() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 15, address, psi: 1 };\n    let note_2 = Note { kind: 2, value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 15, address, psi: 3 };\n    let note_4 = Note { kind: 2, value: 5, address, psi: 4 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_mint() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 15, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 0, address: 0, psi: 0 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 30, address, psi: 3 };\n\n    let commitments = [\n        get_note_commitment(note_1),\n        get_note_commitment(note_2),\n        get_note_commitment(note_3),\n        get_note_commitment(note_4),\n    ];\n\n    let mint_hash = poseidon2::Poseidon2::hash([note_3.psi, note_4.psi], 2);\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        commitments,\n        [2, bridged_note_kind(), 10, mint_hash, 0],\n    )\n}\n\n#[test]\nfn test_burn() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 15, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    let note_3 = Note { kind: 0, value: 0, address: 0, psi: 0 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 10, address, psi: 3 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [3, bridged_note_kind(), 10, get_note_commitment(note_1), 0],\n    )\n}\n\n#[test]\nfn test_send_zero_value() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 0, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 0, address, psi: 3 };\n    let note_4 = Note { kind: 0, value: 0, address, psi: 0 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_mint_with_padding_input() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 5, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 15, address, psi: 3 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 0, address: 0, psi: 0 };\n\n    let commitments = [\n        get_note_commitment(note_1),\n        get_note_commitment(note_2),\n        get_note_commitment(note_3),\n        get_note_commitment(note_4),\n    ];\n\n    let mint_hash = poseidon2::Poseidon2::hash([note_3.psi, note_4.psi], 2);\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        commitments,\n        [2, bridged_note_kind(), 10, mint_hash, 0],\n    )\n}\n\n#[test]\nfn test_burn_single_input() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 15, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    let note_3 = Note { kind: 0, value: 0, address: 0, psi: 0 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 5, address, psi: 3 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [3, bridged_note_kind(), 10, get_note_commitment(note_1), 0],\n    )\n}\n","path":"/Users/matteo/projects/cachecash/noir/utxo_lib/src/lib.nr"}},"expression_width":{"Bounded":{"width":4}}}