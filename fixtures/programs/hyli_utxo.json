{"noir_version":"1.0.0-beta.12+9a5b3695b42e391fa27c48e87b9bbb07523d664d","hash":"11258540527380821879","abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":256},"visibility":"public"},{"name":"tx_hash","type":{"kind":"string","length":64},"visibility":"public"},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_number","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_contract_name_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"blob_contract_name","type":{"kind":"string","length":256},"visibility":"public"},{"name":"blob_capacity","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob","type":{"kind":"array","length":128,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"tx_blob_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"success","type":{"kind":"boolean"},"visibility":"public"},{"name":"input_notes","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"common::InputNote","fields":[{"name":"note","type":{"kind":"struct","path":"common::Note","fields":[{"name":"kind","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}},{"name":"address","type":{"kind":"field"}},{"name":"psi","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"output_notes","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"common::Note","fields":[{"name":"kind","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}},{"name":"address","type":{"kind":"field"}},{"name":"psi","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"pmessage4","type":{"kind":"field"},"visibility":"private"},{"name":"commitments","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},{"name":"messages","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"public"}],"return_type":null,"error_types":{"285656119219400463":{"error_kind":"string","string":"Field failed to decompose into specified 32 limbs"},"1680776573889254733":{"error_kind":"string","string":"blob capacity must be 128 bytes"},"1714809443410094063":{"error_kind":"string","string":"Padding notes must be zero value"},"2309186114595128024":{"error_kind":"string","string":"transaction must provide enough blobs"},"2729061851012865270":{"error_kind":"string","string":"exactly one blob is expected"},"3692929699516101711":{"error_kind":"string","string":"blob must match concatenated commitments"},"3898381286344942305":{"error_kind":"string","string":"Input note is not owned by the owner"},"5851673573934815162":{"error_kind":"string","string":"Mint note kind must match message"},"6441031214723128659":{"error_kind":"string","string":"blob length must be 128 bytes"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6661914514907183551":{"error_kind":"string","string":"Note commitment is not valid"},"8113810225559518305":{"error_kind":"string","string":"unsupported Hyli output version"},"8608850205409006559":{"error_kind":"string","string":"initial_state must be 4 bytes"},"8981409365392375781":{"error_kind":"string","string":"next_state must be 4 bytes"},"9733062431596745772":{"error_kind":"string","string":"Input and output totals do not match"},"10443210886677245255":{"error_kind":"string","string":"Burn note kind must match message"},"11163426053785103653":{"error_kind":"string","string":"blob index must align with invocation index"},"12476573426903251686":{"error_kind":"string","string":"blob contract name must be 9 bytes"},"12775174927910757886":{"error_kind":"string","string":"Inconsistent kinds are not allowed"},"12948852497587922262":{"error_kind":"string","string":"messages[4] must match private input"},"13494519577077120575":{"error_kind":"string","string":"contract execution must succeed"},"14111565803291724431":{"error_kind":"string","string":"identity length overflow"},"14672809696058342244":{"error_kind":"string","string":"Burn output must match value message"},"15138347411163958997":{"error_kind":"string","string":"Mint hash must match message"},"15819538689241197369":{"error_kind":"string","string":"Invalid kind"},"17828285616048074783":{"error_kind":"string","string":"Mint output must match value message"},"18075917454431129723":{"error_kind":"string","string":"Burn hash must match message"}}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"52":{"source":"use poseidon::poseidon2;\n\npub struct Note {\n    pub kind: Field,\n    pub value: Field,\n    pub address: Field,\n    pub psi: Field,\n}\n\npub struct InputNote {\n    pub note: Note,\n    pub secret_key: Field,\n}\n\npub fn check_commitment(note: Note, commitment: Field) {\n    assert(get_note_commitment(note) == commitment, \"Note commitment is not valid\");\n}\n\npub fn get_note_commitment(note: Note) -> Field {\n    if (note.kind == 0) {\n        assert(note.value == 0, \"Padding notes must be zero value\");\n        0\n    } else {\n        poseidon2::Poseidon2::hash(\n            [0x2, note.kind, note.value, note.address, note.psi, 0, 0],\n            7,\n        )\n    }\n}\n\npub fn get_address(secret_key: Field) -> Field {\n    poseidon2::Poseidon2::hash([secret_key, 0], 2)\n}\n\npub fn check_input_note_ownership(input_note: InputNote) {\n    if (input_note.note.value != 0) {\n        assert(\n            get_address(input_note.secret_key) == input_note.note.address,\n            \"Input note is not owned by the owner\",\n        );\n    }\n}\n\npub fn slice<let N: u32, let L: u32>(bytes: [u8; N], start: u32) -> [u8; L] {\n    let end = start + L;\n    assert(end <= N, \"slice: slice end out of bounds\");\n    let mut result = [bytes[0]; L];\n    for i in 0..L {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        as_field += (bytes[i] as Field) * offset;\n        offset *= 256;\n    }\n    as_field\n}\n\npub fn is_one_of(value: Field, one_of: [Field]) -> bool {\n    let mut is_one_of = false;\n    for possible in one_of {\n        if possible == value {\n            is_one_of = true;\n        }\n    }\n    is_one_of\n}\n","path":"/home/alexandre/Documents/repos/cachecash/noir/common/src/lib.nr"},"59":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/alexandre/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"61":{"source":"use common::{\n    check_commitment, check_input_note_ownership, get_address, get_note_commitment, InputNote, Note,\n};\nuse poseidon::poseidon2;\n\npub fn utxo_main(\n    input_notes: [InputNote; 2],\n    output_notes: [Note; 2],\n    pmessage4: Field,\n    commitments: [Field; 4],\n    messages: [Field; 5],\n) {\n    // Check the commitments\n    check_commitment(input_notes[0].note, commitments[0]);\n    check_commitment(input_notes[1].note, commitments[1]);\n    check_commitment(output_notes[0], commitments[2]);\n    check_commitment(output_notes[1], commitments[3]);\n\n    // Check individual outputs are not greater than 240 bits\n    output_notes[0].value.assert_max_bit_size::<240>();\n    output_notes[1].value.assert_max_bit_size::<240>();\n\n    let input_value = input_notes[0].note.value + input_notes[1].note.value;\n\n    let output_value = output_notes[0].value + output_notes[1].value;\n\n    // Check for multiple kinds, not currently supported in this proof\n    let (is_multiple_kinds, _note_kind) = is_multiple_kinds([\n        input_notes[0].note,\n        input_notes[1].note,\n        output_notes[0],\n        output_notes[1],\n    ]);\n    assert(!is_multiple_kinds, \"Inconsistent kinds are not allowed\");\n\n    // Kind of UTXO txn\n    let kind = messages[0];\n\n    // Messages (only for mint/burns, otherwise all zeros)\n    let msg_note_kind = messages[1];\n    let msg_value = messages[2];\n\n    // Assert message value size is max 240 bits to prevent overflow attack\n    msg_value.assert_max_bit_size::<240>();\n\n    let msg_hash = messages[3];\n    let burn_addr = messages[4];\n\n    let mint_hash = poseidon2::Poseidon2::hash([output_notes[0].psi, output_notes[1].psi], 2);\n\n    let burn_hash = commitments[0];\n\n    if (kind == 1) {\n        assert(input_value == output_value, \"Input and output totals do not match\");\n    } else if (kind == 2) {\n        assert(output_value == input_value + msg_value, \"Mint output must match value message\");\n        assert(mint_hash == msg_hash, \"Mint hash must match message\");\n        assert(output_notes[0].kind == msg_note_kind, \"Mint note kind must match message\")\n    } else if (kind == 3) {\n        assert(pmessage4 == burn_addr, \"messages[4] must match private input\");\n        assert(burn_hash == msg_hash, \"Burn hash must match message\");\n        assert(input_value == output_value + msg_value, \"Burn output must match value message\");\n        assert(input_notes[0].note.kind == msg_note_kind, \"Burn note kind must match message\")\n    } else {\n        assert(false, \"Invalid kind\");\n    }\n\n    // Check the user owns the input notes\n    check_input_note_ownership(input_notes[0]);\n    check_input_note_ownership(input_notes[1]);\n}\n\nfn is_multiple_kinds(notes: [Note; 4]) -> (bool, Field) {\n    let mut first_non_zero_kind = 0;\n    let mut is_multiple_kinds = false;\n\n    for i in 0..4 {\n        if !is_multiple_kinds {\n            if notes[i].kind != 0 {\n                if first_non_zero_kind == 0 {\n                    first_non_zero_kind = notes[i].kind;\n                } else if first_non_zero_kind != notes[i].kind {\n                    is_multiple_kinds = true;\n                }\n            }\n        }\n    }\n\n    (is_multiple_kinds, first_non_zero_kind)\n}\n\nfn bridged_note_kind() -> Field {\n    3533694129556768672311144317398675444585744224105014452550528428861358080\n}\n\n#[test]\nfn test_send_two_inputs_two_outputs() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 10, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 1, address, psi: 3 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 14, address, psi: 4 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_send_one_input_two_outputs() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 10, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 1, address, psi: 3 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 9, address, psi: 4 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_send_two_inputs_one_output() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 10, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 15, address, psi: 3 };\n    let note_4 = Note { kind: 0, value: 0, address, psi: 0 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test(should_fail)]\nfn test_send_diff_kinds() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 15, address, psi: 1 };\n    let note_2 = Note { kind: 2, value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 15, address, psi: 3 };\n    let note_4 = Note { kind: 2, value: 5, address, psi: 4 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_mint() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 15, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 0, address: 0, psi: 0 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 30, address, psi: 3 };\n\n    let commitments = [\n        get_note_commitment(note_1),\n        get_note_commitment(note_2),\n        get_note_commitment(note_3),\n        get_note_commitment(note_4),\n    ];\n\n    let mint_hash = poseidon2::Poseidon2::hash([note_3.psi, note_4.psi], 2);\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        commitments,\n        [2, bridged_note_kind(), 10, mint_hash, 0],\n    )\n}\n\n#[test]\nfn test_burn() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 15, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    let note_3 = Note { kind: 0, value: 0, address: 0, psi: 0 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 10, address, psi: 3 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [3, bridged_note_kind(), 10, get_note_commitment(note_1), 0],\n    )\n}\n\n#[test]\nfn test_send_zero_value() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 0, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 0, address, psi: 3 };\n    let note_4 = Note { kind: 0, value: 0, address, psi: 0 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_mint_with_padding_input() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 5, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 15, address, psi: 3 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 0, address: 0, psi: 0 };\n\n    let commitments = [\n        get_note_commitment(note_1),\n        get_note_commitment(note_2),\n        get_note_commitment(note_3),\n        get_note_commitment(note_4),\n    ];\n\n    let mint_hash = poseidon2::Poseidon2::hash([note_3.psi, note_4.psi], 2);\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        commitments,\n        [2, bridged_note_kind(), 10, mint_hash, 0],\n    )\n}\n\n#[test]\nfn test_burn_single_input() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 15, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    let note_3 = Note { kind: 0, value: 0, address: 0, psi: 0 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 5, address, psi: 3 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [3, bridged_note_kind(), 10, get_note_commitment(note_1), 0],\n    )\n}\n","path":"/home/alexandre/Documents/repos/cachecash/noir/utxo_lib/src/lib.nr"},"72":{"source":"use common::{check_commitment, check_input_note_ownership, InputNote, Note};\nuse poseidon::poseidon2;\nuse utxo_lib::utxo_main;\n\nfn field_to_bytes(value: Field) -> [u8; 32] {\n    value.to_be_bytes()\n}\n\n\nfn main(\n    // Hyli-required public plumbing\n    version: pub u32,\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    identity_len: pub u8,\n    identity: pub str<256>,\n    tx_hash: pub str<64>,\n    index: pub u32,\n    blob_number: pub u32,\n    blob_index: pub u32,\n    blob_contract_name_len: pub u8,\n    blob_contract_name: pub str<256>,\n    blob_capacity: pub u32,\n    blob_len: pub u32,\n    blob: pub [u8; 128],\n    tx_blob_count: pub u32,\n    success: pub bool,\n    // Wrapped UTXO inputs (mirrors noir/utxo)\n    input_notes: [InputNote; 2],\n    output_notes: [Note; 2],\n    pmessage4: Field,\n    commitments: pub [Field; 4],\n    messages: pub [Field; 5],\n) {\n    // ---------------------------------------------------------------------\n    // Hyli contract framing\n    // ---------------------------------------------------------------------\n    assert(success, \"contract execution must succeed\");\n    assert(version == 1, \"unsupported Hyli output version\");\n\n    assert(initial_state_len == 4, \"initial_state must be 4 bytes\");\n    assert(next_state_len == 4, \"next_state must be 4 bytes\");\n\n    assert(blob_capacity == 128, \"blob capacity must be 128 bytes\");\n    assert(blob_len == 128, \"blob length must be 128 bytes\");\n    assert(blob_number == 1, \"exactly one blob is expected\");\n    assert(tx_blob_count >= blob_number, \"transaction must provide enough blobs\");\n    assert(blob_index == index, \"blob index must align with invocation index\");\n\n    // // Basic hygiene on the identity payload so the plumbing is exercised.\n    // let identity_bytes = identity.as_bytes();\n    // assert(identity_bytes.len() == identity_len as u32, \"identity_len mismatch\");\n\n    // let tx_hash_bytes = tx_hash.as_bytes();\n    // assert(tx_hash_bytes.len() <= 64, \"tx hash too long\");\n\n    assert(identity_len as u32 <= 256, \"identity length overflow\");\n    assert(blob_contract_name_len == 9, \"blob contract name must be 9 bytes\");\n\n    let _ = initial_state;\n    let _ = next_state;\n\n\n    // ---------------------------------------------------------------------\n    // Call through to the original UTXO circuit\n    // ---------------------------------------------------------------------\n    utxo_main(\n        input_notes,\n        output_notes,\n        pmessage4,\n        commitments,\n        messages,\n    );\n\n    // Mirror key checks so the Hyli host can rely on them directly.\n    check_commitment(input_notes[0].note, commitments[0]);\n    check_commitment(input_notes[1].note, commitments[1]);\n    check_commitment(output_notes[0], commitments[2]);\n    check_commitment(output_notes[1], commitments[3]);\n\n    check_input_note_ownership(input_notes[0]);\n    check_input_note_ownership(input_notes[1]);\n\n    // ---------------------------------------------------------------------\n    // Collect nullifier commitments to expose them through the blob payload.\n    // ---------------------------------------------------------------------\n    let mut nullifier_commitments: [Field; 2] = [0; 2];\n    for i in 0..2 {\n        let note = input_notes[i];\n        let private_commitment = poseidon2::Poseidon2::hash([note.note.psi, note.secret_key], 2);\n        nullifier_commitments[i] = private_commitment;\n    }\n\n    let expected_blob = build_blob_payload(commitments, nullifier_commitments);\n    assert(blob == expected_blob, \"blob must match concatenated commitments\");\n}\n\nfn build_blob_payload(\n    commitments: [Field; 4],\n    nullifier_commitments: [Field; 2],\n) -> [u8; 128] {\n    let mut bytes: [u8; 128] = [0; 128];\n    let mut offset: u32 = 0;\n\n    for i in 0..2 {\n        let commitment_bytes = field_to_bytes(commitments[i]);\n        for j in 0..32 {\n            let j_idx: u32 = j as u32;\n            let index: u32 = offset + j_idx;\n            bytes[index] = commitment_bytes[j_idx];\n        }\n        offset += 32;\n    }\n\n    for i in 0..2 {\n        let commitment_bytes = field_to_bytes(nullifier_commitments[i]);\n        for j in 0..32 {\n            let j_idx: u32 = j as u32;\n            let index: u32 = offset + j_idx;\n            bytes[index] = commitment_bytes[j_idx];\n        }\n        offset += 32;\n    }\n\n    bytes\n}\n\n#[test]\nfn test_build_blob_payload_concatenates_commitments() {\n    let commitments: [Field; 4] = [11, 22, 33, 44];\n    let nullifiers: [Field; 2] = [55, 66];\n    let blob = build_blob_payload(commitments, nullifiers);\n    let mut expected: [u8; 128] = [0; 128];\n\n    let arrays = [\n        field_to_bytes(commitments[0]),\n        field_to_bytes(commitments[1]),\n        field_to_bytes(nullifiers[0]),\n        field_to_bytes(nullifiers[1]),\n    ];\n\n    for i in 0..4 {\n        let start = i * 32;\n        for j in 0..32 {\n            expected[start + j] = arrays[i][j];\n        }\n    }\n\n    assert(blob == expected, \"blob must match concatenated commitment bytes\");\n}\n","path":"/home/alexandre/Documents/repos/cachecash/noir/hyli_utxo/src/main.nr"}},"names":["main"],"brillig_names":["directive_invert","directive_integer_quotient","directive_to_radix"]}