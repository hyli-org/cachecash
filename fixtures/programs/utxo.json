{"noir_version":"1.0.0-beta.12+9a5b3695b42e391fa27c48e87b9bbb07523d664d","hash":"864495292192982944","abi":{"parameters":[{"name":"input_notes","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"common::InputNote","fields":[{"name":"note","type":{"kind":"struct","path":"common::Note","fields":[{"name":"kind","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}},{"name":"address","type":{"kind":"field"}},{"name":"psi","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"output_notes","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"common::Note","fields":[{"name":"kind","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}},{"name":"address","type":{"kind":"field"}},{"name":"psi","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"pmessage4","type":{"kind":"field"},"visibility":"private"},{"name":"commitments","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},{"name":"messages","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"public"}],"return_type":null,"error_types":{"1714809443410094063":{"error_kind":"string","string":"Padding notes must be zero value"},"3898381286344942305":{"error_kind":"string","string":"Input note is not owned by the owner"},"5851673573934815162":{"error_kind":"string","string":"Mint note kind must match message"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6661914514907183551":{"error_kind":"string","string":"Note commitment is not valid"},"9733062431596745772":{"error_kind":"string","string":"Input and output totals do not match"},"10443210886677245255":{"error_kind":"string","string":"Burn note kind must match message"},"12775174927910757886":{"error_kind":"string","string":"Inconsistent kinds are not allowed"},"12948852497587922262":{"error_kind":"string","string":"messages[4] must match private input"},"14672809696058342244":{"error_kind":"string","string":"Burn output must match value message"},"15138347411163958997":{"error_kind":"string","string":"Mint hash must match message"},"15819538689241197369":{"error_kind":"string","string":"Invalid kind"},"17828285616048074783":{"error_kind":"string","string":"Mint output must match value message"},"18075917454431129723":{"error_kind":"string","string":"Burn hash must match message"}}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"50":{"source":"use common::{InputNote, Note};\nuse utxo_lib::utxo_main;\n\nfn main(\n    input_notes: [InputNote; 2],\n    output_notes: [Note; 2],\n    pmessage4: Field,\n    commitments: pub [Field; 4],\n    messages: pub [Field; 5],\n) {\n    utxo_main(\n        input_notes,\n        output_notes,\n        pmessage4,\n        commitments,\n        messages,\n    );\n}\n","path":"/home/alexandre/Documents/repos/zfruit/noir/utxo/src/main.nr"},"52":{"source":"use poseidon::poseidon2;\n\npub struct Note {\n    pub kind: Field,\n    pub value: Field,\n    pub address: Field,\n    pub psi: Field,\n}\n\npub struct InputNote {\n    pub note: Note,\n    pub secret_key: Field,\n}\n\npub fn check_commitment(note: Note, commitment: Field) {\n    assert(get_note_commitment(note) == commitment, \"Note commitment is not valid\");\n}\n\npub fn get_note_commitment(note: Note) -> Field {\n    if (note.kind == 0) {\n        assert(note.value == 0, \"Padding notes must be zero value\");\n        0\n    } else {\n        poseidon2::Poseidon2::hash(\n            [0x2, note.kind, note.value, note.address, note.psi, 0, 0],\n            7,\n        )\n    }\n}\n\npub fn get_address(secret_key: Field) -> Field {\n    poseidon2::Poseidon2::hash([secret_key, 0], 2)\n}\n\npub fn check_input_note_ownership(input_note: InputNote) {\n    if (input_note.note.value != 0) {\n        assert(\n            get_address(input_note.secret_key) == input_note.note.address,\n            \"Input note is not owned by the owner\",\n        );\n    }\n}\n\npub fn slice<let N: u32, let L: u32>(bytes: [u8; N], start: u32) -> [u8; L] {\n    let end = start + L;\n    assert(end <= N, \"slice: slice end out of bounds\");\n    let mut result = [bytes[0]; L];\n    for i in 0..L {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        as_field += (bytes[i] as Field) * offset;\n        offset *= 256;\n    }\n    as_field\n}\n\npub fn is_one_of(value: Field, one_of: [Field]) -> bool {\n    let mut is_one_of = false;\n    for possible in one_of {\n        if possible == value {\n            is_one_of = true;\n        }\n    }\n    is_one_of\n}\n","path":"/home/alexandre/Documents/repos/zfruit/noir/common/src/lib.nr"},"59":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/alexandre/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"61":{"source":"use common::{\n    check_commitment, check_input_note_ownership, get_address, get_note_commitment, InputNote, Note,\n};\nuse poseidon::poseidon2;\n\npub fn utxo_main(\n    input_notes: [InputNote; 2],\n    output_notes: [Note; 2],\n    pmessage4: Field,\n    commitments: [Field; 4],\n    messages: [Field; 5],\n) {\n    // Check the commitments\n    check_commitment(input_notes[0].note, commitments[0]);\n    check_commitment(input_notes[1].note, commitments[1]);\n    check_commitment(output_notes[0], commitments[2]);\n    check_commitment(output_notes[1], commitments[3]);\n\n    // Check individual outputs are not greater than 240 bits\n    output_notes[0].value.assert_max_bit_size::<240>();\n    output_notes[1].value.assert_max_bit_size::<240>();\n\n    let input_value = input_notes[0].note.value + input_notes[1].note.value;\n\n    let output_value = output_notes[0].value + output_notes[1].value;\n\n    // Check for multiple kinds, not currently supported in this proof\n    let (is_multiple_kinds, _note_kind) = is_multiple_kinds([\n        input_notes[0].note,\n        input_notes[1].note,\n        output_notes[0],\n        output_notes[1],\n    ]);\n    assert(!is_multiple_kinds, \"Inconsistent kinds are not allowed\");\n\n    // Kind of UTXO txn\n    let kind = messages[0];\n\n    // Messages (only for mint/burns, otherwise all zeros)\n    let msg_note_kind = messages[1];\n    let msg_value = messages[2];\n\n    // Assert message value size is max 240 bits to prevent overflow attack\n    msg_value.assert_max_bit_size::<240>();\n\n    let msg_hash = messages[3];\n    let burn_addr = messages[4];\n\n    let mint_hash = poseidon2::Poseidon2::hash([output_notes[0].psi, output_notes[1].psi], 2);\n\n    let burn_hash = commitments[0];\n\n    if (kind == 1) {\n        assert(input_value == output_value, \"Input and output totals do not match\");\n    } else if (kind == 2) {\n        assert(output_value == input_value + msg_value, \"Mint output must match value message\");\n        assert(mint_hash == msg_hash, \"Mint hash must match message\");\n        assert(output_notes[0].kind == msg_note_kind, \"Mint note kind must match message\")\n    } else if (kind == 3) {\n        assert(pmessage4 == burn_addr, \"messages[4] must match private input\");\n        assert(burn_hash == msg_hash, \"Burn hash must match message\");\n        assert(input_value == output_value + msg_value, \"Burn output must match value message\");\n        assert(input_notes[0].note.kind == msg_note_kind, \"Burn note kind must match message\")\n    } else {\n        assert(false, \"Invalid kind\");\n    }\n\n    // Check the user owns the input notes\n    check_input_note_ownership(input_notes[0]);\n    check_input_note_ownership(input_notes[1]);\n}\n\nfn is_multiple_kinds(notes: [Note; 4]) -> (bool, Field) {\n    let mut first_non_zero_kind = 0;\n    let mut is_multiple_kinds = false;\n\n    for i in 0..4 {\n        if !is_multiple_kinds {\n            if notes[i].kind != 0 {\n                if first_non_zero_kind == 0 {\n                    first_non_zero_kind = notes[i].kind;\n                } else if first_non_zero_kind != notes[i].kind {\n                    is_multiple_kinds = true;\n                }\n            }\n        }\n    }\n\n    (is_multiple_kinds, first_non_zero_kind)\n}\n\nfn bridged_note_kind() -> Field {\n    3533694129556768672311144317398675444585744224105014452550528428861358080\n}\n\n#[test]\nfn test_send_two_inputs_two_outputs() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 10, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 1, address, psi: 3 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 14, address, psi: 4 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_send_one_input_two_outputs() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 10, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 1, address, psi: 3 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 9, address, psi: 4 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_send_two_inputs_one_output() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 10, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 15, address, psi: 3 };\n    let note_4 = Note { kind: 0, value: 0, address, psi: 0 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test(should_fail)]\nfn test_send_diff_kinds() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 15, address, psi: 1 };\n    let note_2 = Note { kind: 2, value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 15, address, psi: 3 };\n    let note_4 = Note { kind: 2, value: 5, address, psi: 4 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_mint() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 15, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 0, address: 0, psi: 0 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 30, address, psi: 3 };\n\n    let commitments = [\n        get_note_commitment(note_1),\n        get_note_commitment(note_2),\n        get_note_commitment(note_3),\n        get_note_commitment(note_4),\n    ];\n\n    let mint_hash = poseidon2::Poseidon2::hash([note_3.psi, note_4.psi], 2);\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        commitments,\n        [2, bridged_note_kind(), 10, mint_hash, 0],\n    )\n}\n\n#[test]\nfn test_burn() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 15, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    let note_3 = Note { kind: 0, value: 0, address: 0, psi: 0 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 10, address, psi: 3 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [3, bridged_note_kind(), 10, get_note_commitment(note_1), 0],\n    )\n}\n\n#[test]\nfn test_send_zero_value() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 0, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 0, address, psi: 3 };\n    let note_4 = Note { kind: 0, value: 0, address, psi: 0 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_mint_with_padding_input() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 5, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    let note_3 = Note { kind: bridged_note_kind(), value: 15, address, psi: 3 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 0, address: 0, psi: 0 };\n\n    let commitments = [\n        get_note_commitment(note_1),\n        get_note_commitment(note_2),\n        get_note_commitment(note_3),\n        get_note_commitment(note_4),\n    ];\n\n    let mint_hash = poseidon2::Poseidon2::hash([note_3.psi, note_4.psi], 2);\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        commitments,\n        [2, bridged_note_kind(), 10, mint_hash, 0],\n    )\n}\n\n#[test]\nfn test_burn_single_input() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    let note_1 = Note { kind: bridged_note_kind(), value: 15, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    let note_3 = Note { kind: 0, value: 0, address: 0, psi: 0 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 5, address, psi: 3 };\n\n    utxo_main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [3, bridged_note_kind(), 10, get_note_commitment(note_1), 0],\n    )\n}\n","path":"/home/alexandre/Documents/repos/zfruit/noir/utxo_lib/src/lib.nr"}},"names":["main"],"brillig_names":["directive_invert"]}