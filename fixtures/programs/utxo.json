{"noir_version":"1.0.0-beta.9+6abff2f16e1c1314ba30708d1cf032a536de3d19","hash":"6227542182025880053","abi":{"parameters":[{"name":"input_notes","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"common::InputNote","fields":[{"name":"note","type":{"kind":"struct","path":"common::Note","fields":[{"name":"kind","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}},{"name":"address","type":{"kind":"field"}},{"name":"psi","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"output_notes","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"common::Note","fields":[{"name":"kind","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}},{"name":"address","type":{"kind":"field"}},{"name":"psi","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"pmessage4","type":{"kind":"field"},"visibility":"private"},{"name":"commitments","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},{"name":"messages","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"public"}],"return_type":null,"error_types":{"1714809443410094063":{"error_kind":"string","string":"Padding notes must be zero value"},"3898381286344942305":{"error_kind":"string","string":"Input note is not owned by the owner"},"5851673573934815162":{"error_kind":"string","string":"Mint note kind must match message"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6661914514907183551":{"error_kind":"string","string":"Note commitment is not valid"},"9733062431596745772":{"error_kind":"string","string":"Input and output totals do not match"},"10443210886677245255":{"error_kind":"string","string":"Burn note kind must match message"},"12775174927910757886":{"error_kind":"string","string":"Inconsistent kinds are not allowed"},"12948852497587922262":{"error_kind":"string","string":"messages[4] must match private input"},"14672809696058342244":{"error_kind":"string","string":"Burn output must match value message"},"15138347411163958997":{"error_kind":"string","string":"Mint hash must match message"},"15819538689241197369":{"error_kind":"string","string":"Invalid kind"},"17828285616048074783":{"error_kind":"string","string":"Mint output must match value message"},"18075917454431129723":{"error_kind":"string","string":"Burn hash must match message"}}},"bytecode":"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","debug_symbols":"tVrRjlspDP2XPOcBY7Chv7JaVek0rSJFmVE6U2lV9d8X32DuTCUQwurL2EnG5lyDDwbfX4ev5y9v3z9fbt+efxw+/fPr8OV+uV4v3z9fn59Or5fnW/n21+/jQT9+fr2fz+Wrw7vfi9XL6X6+vR4+3d6u1+Ph5+n6tv3Tj5fTbZOvp3v51R0P59vXIovDb5frWbTfx93a9U2RYjVGzs08ztsnqvbBuRX7kJo99Oyxb++54X8/vv9gH/r2ATR4wYcV+4BqH9OCffT6/FSMOvY8iF/0Oj7Qbp8/2KdB/HzK1YFH53sect8DoFMPgD71PMBgEeSgk5jjkgNwXsMAjqIRA8eVMAA1CJDiylRQ0rXoKWP3IaJ9LsgcytFzMCgneEbXBTFwAcyaVsC5uyohW9fUCEPeY5l9F8McN0GXWwZLsjCS5jamBW4NLQQhrnB7cKz21OV2H43k7MnIzkMHM/Q8cjDFzz4bCRqdmaERzLSA3phOIweTvDKJoU/RwzjMcfRwNuZIGtk+G8keTGdm6eDMLB3AuKyGGOZYepKl1mg6NY7JKzQdna6o+H78eZomavaxZx/YWkMnaxGdrFV0MtJ0BCNNR2+m6YhmYojBmE8jB5PMMomhT9PDOMzR9HA25mg62s81ZD+WDB9kjqbJm2ma0LishhjmaHqSpZZoOqJSRIy4QtNRx4+0Uk1HD2rP3WqaspGm2RlpeuhghqbZWW870EjTHMw0zfZDNpMxn9h+Sp/E0KfpYRzmaHo4G3M0nexnm2Q/mgwfZI6mUzDTdIrGZTXEMEfTkyy1RNOEiqCsjR5NpgGA2MJIsDuANA0g6wMwUg9Ahr8HAID13ge854WtBkLUvQZCphUPFDQxgWJY8gAtqTj0Azm6ewktkjFkXnJBrh2OCNaeg1pKUMI1EIEbiEUXAfdQRFh6jpzafMAaCMithIH3DDUPgv3OcUt3msCxTQfzSnL4ne29w5VK0AO0GgLQLXlodYwHWsLgQ9twPHeP/eD+IlN63iPJa5HkVlR7phWi8rldkvvc5wgAa1EJYK8qAezl1BjHZOsF2N57GfVO5povYL/hHD/JXDUz6k5jO7Ag4grbFCtoHpauBzFEnVMMFJd69I11MQVa8tBaQaseMup8Yl46fweH0F4VoKV+GPg90XFlEw0eW0vNx5X1EHA/QyOtXfeG3NpyvBRJwmD0sO/CIS299xESteZi4pVaolSEfr93pyUPe4M0p/7eMWrmpLasU/9KZOwha6Wd+7cygIN9nKGdWAi6HkZdlLkdcNTImd0Bgzcf5SFYbyrHsWh1coC4FovJXTiQfRce3ZjO7qFDHHN76OwKj7BwJRCdbx0yh0ucmTPuHvrV8ugmfi7Thx6mMn3UWpnL9BitmR7JnunR3gKHaK4xh7GYyvRhLCYzncCe6WS/wRzjmMz0yRX+R6b/Wz6dni73D++/Hlz58XiA7a/f/mI5jB4PQa6+jof4EPQQ/BDpIfJDgJOwFQmyMov0MhVFYpWhyuJLankgKaOL5CpTlfkhvZN1USRIu6NIL+xRJFYZqozCHkWSXOoUyVWmKvNDopPTdZHFn/Tp0UsWF4lVhiqLP6lnsPjjghO5ylRlfsjghImKLP6SfC7+JOgBhVWKDHKfX2SskqrkKou/XPCH/JDRVQmydIqj6FVBVYIqURVShVVJqsi8uPJA5FSBx8jkq8QqK1KqSGlzKtPNqiRVcvXOThWFywqXFS4rXFa4rHBZ4bLCZYWbFG4CVbwqFXCqgFMFnGpoUw1t2pyWNZNyVbJTReFmhZsVbla4WeFmhZsVbla4efMsKePEtfTzCkTJhE3zTcOmbam0JUpsGjVtyykUbUsrSQSXVdty66FtY5BovmnYtG2MLQm3MSTNYBsji8ZNS03Lqkm+gbynBJJxVZMx5LAHknUgN58geQdbokrmgRzDQHIPpKsLkn1VS02TMeSdEZAcBElWkCwEefUAJA+rhk2TMWjTZIyNR3+e7pfTl+u5vq7/7e329O7t/df/XvQXfb//5f78dP76dj8L022/Fe77Hw==","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"50":{"source":"use common::{\n    check_commitment, check_input_note_ownership, get_address, get_note_commitment, InputNote, Note,\n};\nuse poseidon::poseidon2;\n\nmod test;\n\nfn main(\n    input_notes: [InputNote; 2],\n    output_notes: [Note; 2],\n    pmessage4: Field,\n    commitments: pub [Field; 4],\n    messages: pub [Field; 5],\n) {\n    // Check the commitments\n    check_commitment(input_notes[0].note, commitments[0]);\n    check_commitment(input_notes[1].note, commitments[1]);\n    check_commitment(output_notes[0], commitments[2]);\n    check_commitment(output_notes[1], commitments[3]);\n\n    // Check individual outputs are not greater than 240 bits\n    output_notes[0].value.assert_max_bit_size::<240>();\n    output_notes[1].value.assert_max_bit_size::<240>();\n\n    // We do not need to check the input notes values, as they must already have been added\n    // to the tree, and the only way for that to occur if them to be added as an output note first\n    // (which the check below would catch). Also, an overflow attack on the inputs would be deterimental\n    // to the attacker as they would have to provide more input funds, and would receive less output funds.\n    let input_value = input_notes[0].note.value + input_notes[1].note.value;\n\n    // Because we have already checked the individual output notes are no greater than 240 bits,\n    // then the maximum of the addition can be 2^241 which means the output value can never overflow\n    let output_value = output_notes[0].value + output_notes[1].value;\n\n    // Check for multiple kinds, not currently supported in this proof\n    let (is_multiple_kinds, _note_kind) = is_multiple_kinds([\n        input_notes[0].note,\n        input_notes[1].note,\n        output_notes[0],\n        output_notes[1],\n    ]);\n    assert(!is_multiple_kinds, \"Inconsistent kinds are not allowed\");\n\n    // Kind of UTXO txn (in future we may have subtypes for kind, which define different encodings\n    // but for now its easier to define this way, so bytes[32] will always be main kind)\n    let kind = messages[0];\n\n    // Messages (only for mint/burns, otherwise all zeros)\n    let msg_note_kind = messages[1];\n    let msg_value = messages[2];\n\n    // Assert message value size is max 240 bits to prevent overflow attack\n    msg_value.assert_max_bit_size::<240>();\n\n    // We only constrain the message hash for mints. For burns, any hash can be used\n    // as its only used by the substitutor to early release funds. Early release is\n    // secured by the validator, so as long as it records the burn hash it should be valid.\n    // A user could provide a burn hash that is already used, which would prevent\n    // a the substitutor from substituting the burn; this is acceptable.\n    let msg_hash = messages[3];\n    let burn_addr = messages[4];\n\n    // Mint hash - we use the private message to prevent others from\n    // being able to frontrun the mint hash in their own utxo txn\n    let mint_hash = poseidon2::Poseidon2::hash([output_notes[0].psi, output_notes[1].psi], 2);\n\n    // Burn hash - used for the burn substitutor and to verify status of an existing burn -\n    // could be any hash so long as its asserted in the proof and cannot be modified. We were\n    // planning to use the commitment of both inputs, but that is extra work and not neccessary.\n    let burn_hash = commitments[0];\n\n    if (kind == 1) {\n        //SEND\n        assert(input_value == output_value, \"Input and output totals do not match\");\n    } else if (kind == 2) {\n        // MINT\n        // Assert mint utxo is balanced:\n        //   - `output_value` is checked above\n        //   - `input_value` is checked as it must have previously been an output value\n        //   - `msg_value` is checked above (but also using that to overflow would be detrimental to the\n        //      attacker)\n        assert(output_value == input_value + msg_value, \"Mint output must match value message\");\n        // Assert mint hash\n        assert(mint_hash == msg_hash, \"Mint hash must match message\");\n        // Assert note kind\n        assert(output_notes[0].kind == msg_note_kind, \"Mint note kind must match message\")\n    } else if (kind == 3) {\n        // BURN\n        // Prevent frontrunning the txn and changing the evm address\n        assert(pmessage4 == burn_addr, \"messages[4] must match private input\");\n        // Assert burn hash\n        assert(burn_hash == msg_hash, \"Burn hash must match message\");\n        // Assert burn utxo is balanced:\n        //   - `output_value` is checked above\n        //   - `input_value` is checked as it must have previously been an output value\n        //   - `msg_value` is checked above\n        assert(input_value == output_value + msg_value, \"Burn output must match value message\");\n        // Assert burn kind\n        assert(input_notes[0].note.kind == msg_note_kind, \"Burn note kind must match message\")\n    } else {\n        assert(false, \"Invalid kind\");\n    }\n\n    // Check the user owns the input notes\n    check_input_note_ownership(input_notes[0]);\n    check_input_note_ownership(input_notes[1]);\n}\n\nfn is_multiple_kinds(notes: [Note; 4]) -> (bool, Field) {\n    let mut first_non_zero_kind = 0;\n    let mut is_multiple_kinds = false;\n\n    for i in 0..4 {\n        // Skip if we have already detected multiple kinds - basically an early return\n        // (which is not supported directly in Noir)\n        if !is_multiple_kinds {\n            // Check if this is a non-padding note\n            if notes[i].kind != 0 {\n                if first_non_zero_kind == 0 {\n                    // No previous kind exists, so add this one\n                    first_non_zero_kind = notes[i].kind;\n                } else if first_non_zero_kind != notes[i].kind {\n                    // We've detected a mismatched kind\n                    is_multiple_kinds = true;\n                }\n            }\n        }\n    }\n\n    (is_multiple_kinds, first_non_zero_kind)\n}\n\nfn bridged_note_kind() -> Field {\n    3533694129556768672311144317398675444585744224105014452550528428861358080\n}\n\n#[test]\nfn test_send_two_inputs_two_outputs() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs\n    let note_1 = Note { kind: bridged_note_kind(), value: 10, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs\n    let note_3 = Note { kind: bridged_note_kind(), value: 1, address, psi: 3 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 14, address, psi: 4 };\n\n    // Commitments\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_send_one_input_two_outputs() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs\n    let note_1 = Note { kind: bridged_note_kind(), value: 10, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    // Outputs\n    let note_3 = Note { kind: bridged_note_kind(), value: 1, address, psi: 3 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 9, address, psi: 4 };\n\n    // Commitments\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_send_two_inputs_one_output() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs\n    let note_1 = Note { kind: bridged_note_kind(), value: 10, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs\n    let note_3 = Note { kind: bridged_note_kind(), value: 15, address, psi: 3 };\n    let note_4 = Note { kind: 0, value: 0, address, psi: 0 };\n\n    // Commitments\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test(should_fail)]\nfn test_send_diff_kinds() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs\n    let note_1 = Note { kind: bridged_note_kind(), value: 15, address, psi: 1 };\n    let note_2 = Note { kind: 2, value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs\n    let note_3 = Note { kind: bridged_note_kind(), value: 15, address, psi: 3 };\n    let note_4 = Note { kind: 2, value: 5, address, psi: 4 };\n\n    // Commitments\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_mint() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs\n    let note_1 = Note { kind: bridged_note_kind(), value: 15, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs\n    let note_3 = Note { kind: bridged_note_kind(), value: 0, address: 0, psi: 0 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 30, address, psi: 3 };\n\n    let commitments = [\n        get_note_commitment(note_1),\n        get_note_commitment(note_2),\n        get_note_commitment(note_3),\n        get_note_commitment(note_4),\n    ];\n\n    let mint_hash = poseidon2::Poseidon2::hash([note_3.psi, note_4.psi], 2);\n\n    // Commitments\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        commitments,\n        [2, bridged_note_kind(), 10, mint_hash, 0],\n    )\n}\n\n#[test]\nfn test_burn() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs\n    let note_1 = Note { kind: bridged_note_kind(), value: 15, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs\n    let note_3 = Note { kind: 0, value: 0, address: 0, psi: 0 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 10, address, psi: 3 };\n\n    // Commitments\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [3, bridged_note_kind(), 10, get_note_commitment(note_1), 0],\n    )\n}\n\n#[test]\nfn test_send_zero_value() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs - both zero value notes\n    let note_1 = Note { kind: bridged_note_kind(), value: 0, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    // Outputs - both zero value notes\n    let note_3 = Note { kind: bridged_note_kind(), value: 0, address, psi: 3 };\n    let note_4 = Note { kind: 0, value: 0, address, psi: 0 };\n\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_mint_with_padding_input() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs - one real note, one padding\n    let note_1 = Note { kind: bridged_note_kind(), value: 5, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    // Outputs - note_3 is the first output (minted note), note_4 is padding or same kind\n    let note_3 = Note { kind: bridged_note_kind(), value: 15, address, psi: 3 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 0, address: 0, psi: 0 };\n\n    let commitments = [\n        get_note_commitment(note_1),\n        get_note_commitment(note_2),\n        get_note_commitment(note_3),\n        get_note_commitment(note_4),\n    ];\n\n    let mint_hash = poseidon2::Poseidon2::hash([note_3.psi, note_4.psi], 2);\n\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        commitments,\n        [2, bridged_note_kind(), 10, mint_hash, 0],\n    )\n}\n\n#[test]\nfn test_burn_single_input() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs - one real note, one padding\n    let note_1 = Note { kind: bridged_note_kind(), value: 15, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    // Outputs - burn 10 value, keep 5\n    let note_3 = Note { kind: 0, value: 0, address: 0, psi: 0 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 5, address, psi: 3 };\n\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [3, bridged_note_kind(), 10, get_note_commitment(note_1), 0],\n    )\n}\n#[test(should_fail)]\nfn test_mint_different_kinds() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs - mix of different kinds\n    let note_1 = Note { kind: bridged_note_kind(), value: 5, address, psi: 1 };\n    let note_2 = Note { kind: 2, value: 3, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs - mint kind 3, first note is the minted note\n    let note_3 = Note { kind: 3, value: 18, address, psi: 3 };\n    let note_4 = Note { kind: 0, value: 0, address: 0, psi: 0 };\n\n    let commitments = [\n        get_note_commitment(note_1),\n        get_note_commitment(note_2),\n        get_note_commitment(note_3),\n        get_note_commitment(note_4),\n    ];\n\n    let mint_hash = poseidon2::Poseidon2::hash([note_3.psi, note_4.psi], 2);\n\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        commitments,\n        [2, 3, 10, mint_hash, 0],\n    )\n}\n\n#[test]\nfn test_send_large_values() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Test with larger values (but still within 240-bit constraint)\n    let large_value = 1000000000;\n\n    // Inputs\n    let note_1 = Note { kind: bridged_note_kind(), value: large_value, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: large_value, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs\n    let note_3 = Note { kind: bridged_note_kind(), value: large_value + 500000, address, psi: 3 };\n    let note_4 = Note { kind: bridged_note_kind(), value: large_value - 500000, address, psi: 4 };\n\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_mint_same_kind() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs - same kind\n    let note_1 = Note { kind: bridged_note_kind(), value: 5, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 10, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs - mint more of same kind, first note is the minted note\n    let note_3 = Note { kind: bridged_note_kind(), value: 25, address, psi: 3 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 0, address: 0, psi: 0 };\n\n    let commitments = [\n        get_note_commitment(note_1),\n        get_note_commitment(note_2),\n        get_note_commitment(note_3),\n        get_note_commitment(note_4),\n    ];\n\n    let mint_hash = poseidon2::Poseidon2::hash([note_3.psi, note_4.psi], 2);\n\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        commitments,\n        [2, bridged_note_kind(), 10, mint_hash, 0],\n    )\n}\n\n#[test(should_fail)]\nfn test_overflow_input_first_note() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Create a value that exceeds 240 bits\n    // 2^240 = 1766847064778384329583297500742918515827483896875618958121606201292619776\n    let overflow_value = 1766847064778384329583297500742918515827483896875618958121606201292619777;\n\n    // Inputs - first note has overflow value\n    let note_1 = Note { kind: bridged_note_kind(), value: overflow_value, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs\n    let note_3 = Note { kind: bridged_note_kind(), value: 10, address, psi: 3 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 5, address, psi: 4 };\n\n    // This should fail due to overflow check on first input\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test(should_fail)]\nfn test_overflow_input_second_note() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Create a value that exceeds 240 bits\n    let overflow_value = 1766847064778384329583297500742918515827483896875618958121606201292619777;\n\n    // Inputs - second note has overflow value\n    let note_1 = Note { kind: bridged_note_kind(), value: 5, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: overflow_value, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs\n    let note_3 = Note { kind: bridged_note_kind(), value: 10, address, psi: 3 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 5, address, psi: 4 };\n\n    // This should fail due to overflow check on second input\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test(should_fail)]\nfn test_overflow_output_first_note() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Create a value that exceeds 240 bits\n    let overflow_value = 1766847064778384329583297500742918515827483896875618958121606201292619777;\n\n    // Inputs\n    let note_1 = Note { kind: bridged_note_kind(), value: 10, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs - first output has overflow value\n    let note_3 = Note { kind: bridged_note_kind(), value: overflow_value, address, psi: 3 };\n    let note_4 = Note { kind: bridged_note_kind(), value: 5, address, psi: 4 };\n\n    // This should fail due to overflow check on first output\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test(should_fail)]\nfn test_overflow_output_second_note() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Create a value that exceeds 240 bits\n    let overflow_value = 1766847064778384329583297500742918515827483896875618958121606201292619777;\n\n    // Inputs\n    let note_1 = Note { kind: bridged_note_kind(), value: 10, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs - second output has overflow value\n    let note_3 = Note { kind: bridged_note_kind(), value: 5, address, psi: 3 };\n    let note_4 = Note { kind: bridged_note_kind(), value: overflow_value, address, psi: 4 };\n\n    // This should fail due to overflow check on second output\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_max_allowed_value() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Use a value that is exactly at the 240-bit limit (2^240 - 1)\n    let max_value = 1766847064778384329583297500742918515827483896875618958121606201292619775;\n\n    // Inputs - both notes have max allowed value\n    let note_1 = Note { kind: bridged_note_kind(), value: max_value, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    // Outputs - transfer to single output\n    let note_3 = Note { kind: bridged_note_kind(), value: max_value, address, psi: 3 };\n    let note_4 = Note { kind: 0, value: 0, address, psi: 0 };\n\n    // This should succeed as the value is exactly at the limit\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0],\n    )\n}\n\n#[test(should_fail)]\nfn test_msg_value_overflow() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Create a value that exceeds 240 bits\n    let overflow_value = 1766847064778384329583297500742918515827483896875618958121606201292619777;\n\n    // Inputs\n    let note_1 = Note { kind: bridged_note_kind(), value: 10, address, psi: 1 };\n    let note_2 = Note { kind: bridged_note_kind(), value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs - mint with overflow msg_value\n    let note_3 = Note { kind: bridged_note_kind(), value: 15, address, psi: 3 };\n    let note_4 = Note { kind: 0, value: 0, address: 0, psi: 0 };\n\n    let commitments = [\n        get_note_commitment(note_1),\n        get_note_commitment(note_2),\n        get_note_commitment(note_3),\n        get_note_commitment(note_4),\n    ];\n\n    let mint_hash = poseidon2::Poseidon2::hash([note_3.psi, note_4.psi], 2);\n\n    // This should fail due to msg_value overflow check\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        commitments,\n        [2, bridged_note_kind(), overflow_value, mint_hash, 0],\n    )\n}\n","path":"/Users/calummoore/conductor/repo/zk-rollup/calummoore-petra/noir/utxo/src/main.nr"},"52":{"source":"use poseidon::poseidon2;\n\npub struct Note {\n    pub kind: Field,\n    pub value: Field,\n    pub address: Field,\n    pub psi: Field,\n}\n\npub struct InputNote {\n    pub note: Note,\n    pub secret_key: Field,\n}\n\npub fn check_commitment(note: Note, commitment: Field) {\n    assert(get_note_commitment(note) == commitment, \"Note commitment is not valid\");\n}\n\npub fn get_note_commitment(note: Note) -> Field {\n    if (note.kind == 0) {\n        assert(note.value == 0, \"Padding notes must be zero value\");\n        0\n    } else {\n        poseidon2::Poseidon2::hash(\n            [0x2, note.kind, note.value, note.address, note.psi, 0, 0],\n            7,\n        )\n    }\n}\n\npub fn get_address(secret_key: Field) -> Field {\n    poseidon2::Poseidon2::hash([secret_key, 0], 2)\n}\n\npub fn check_input_note_ownership(input_note: InputNote) {\n    if (input_note.note.value != 0) {\n        assert(\n            get_address(input_note.secret_key) == input_note.note.address,\n            \"Input note is not owned by the owner\",\n        );\n    }\n}\n\npub fn slice<let N: u32, let L: u32>(bytes: [u8; N], start: u32) -> [u8; L] {\n    let end = start + L;\n    assert(end <= N, \"slice: slice end out of bounds\");\n    let mut result = [bytes[0]; L];\n    for i in 0..L {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        as_field += (bytes[i] as Field) * offset;\n        offset *= 256;\n    }\n    as_field\n}\n\npub fn is_one_of(value: Field, one_of: [Field]) -> bool {\n    let mut is_one_of = false;\n    for possible in one_of {\n        if possible == value {\n            is_one_of = true;\n        }\n    }\n    is_one_of\n}\n","path":"/Users/calummoore/conductor/repo/zk-rollup/calummoore-petra/noir/common/src/lib.nr"},"59":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/calummoore/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_invert"]}