{"noir_version":"1.0.0-beta.9+6abff2f16e1c1314ba30708d1cf032a536de3d19","hash":"1005196609040896285","abi":{"parameters":[{"name":"verification_key","type":{"kind":"array","length":115,"type":{"kind":"field"}},"visibility":"private"},{"name":"verification_key_hash","type":{"kind":"field"},"visibility":"private"},{"name":"utxo_agg_proofs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"UtxoAggProof","fields":[{"name":"proof","type":{"kind":"array","length":508,"type":{"kind":"field"}}},{"name":"old_root","type":{"kind":"field"}},{"name":"new_root","type":{"kind":"field"}},{"name":"commit_hash","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"old_root","type":{"kind":"field"},"visibility":"public"},{"name":"new_root","type":{"kind":"field"},"visibility":"public"},{"name":"commit_hash","type":{"kind":"field"},"visibility":"public"},{"name":"messages","type":{"kind":"array","length":30,"type":{"kind":"field"}},"visibility":"public"}],"return_type":null,"error_types":{"6622469808309600859":{"error_kind":"string","string":"proof old_root must match previous root"},"8016078727437709872":{"error_kind":"string","string":"only agg_utxo proof allowed"},"14733917638491950699":{"error_kind":"string","string":"Roots must match"}}},"bytecode":"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1kzWXNZC1lLWStZa1kbWVtZO1l7WQdZR1knWWdZF1lXWTdZd1kPWU9ZL1lvWR9ZX1k/WXzZANlA2SDZYNkQ2VDZMNlw2QjZSNko2WjZGNlY2TjZeNkE2UTZJNlk2RTZVNk02XTZDNlM2SzZbNkc2VzZPNl+2QLZQtki2WLZEtlS2TLZctkK2UrZKtlq2RrZWtk62XrZBtlG2SbZZtkW2VbZNtl22Q7ZTtku2W7ZHtle2T7ZfdkB2UHZIdlh2RHZUdkx2XHZCdlJ2SnZadkZ2VnZOdl52QXZRdkl2WXZFdlV2TXZddkN2U3ZLdlt2R3ZXdk92X/ZA9lD2SPZY9kT2VPZM9lz2QvZS9kr2WvZG9lb2TvZe9kH2UfZJ9ln2RfZV9k323fXPHcafsl+y3zLnD35XmZssnMxdFl4WQRZRFkkWWRZFFlUWTRZdFkMWUxZLFlsWRxZXFk8WX5ZAllCWSJZYlkSWVJZMllyWQpZSlkqWWpZGllaWTpZelkGWUZZJllmWRZZVlk2WXZZDllPmIfOUecm8ZT4yX5mfzF8WIAuU5ZLlluWR5ZXlk+V3vrYgKygrJCssKyIrKismKy4rISspKyUrLSsjKysrJysvqyBzXnPeeY1z5zW1nddwdl4z2HmNWuc1UZ3X4HRe89F5jUHnNe2c11BzXrPLeY0o5zWJGsic11xxXuPDeU0J5zUMnGfmO89od54J7jyD2nnmsfOMXeeZrs4zRJ1nVjrPSHSeyef876ucr5E4/z2lvayDrKOsk6yzrIusq6ybrLush6ynrJest6yPrK+sn6y/bIBsoGyQbLBsiGyobJhsuGyEbKRslGy0bIxsrGycbLxsgmyibJJssmyKbKpsmmy6bIZspmyWbLZsjmyubJ5svmyBbKFskWyxbIlsqWyZbLlshWylbJVstWyNbK1snWy9bINso2yTbLNsi2yrbJtsu2yHbKdsl2y3bI9sr2yfbL/sgOyg7JDssOyI7KjsmOy47ITspOyU7LTsjOys7JzsvOyC7KLskuyy7Irsquya7Lrshuym7JbstuyO7K7snuy+7IHsoeyR7LHsieyp7JnsueyF7KXsley17I3sreyd7L3sg+yj7JPss+yL7Kvsm+y77Ifsp+yX7LfM+Yd+V5mbLJzMXRZeFkEWURZJFlkWRRZVFk0WXRZDFlMWSxZbFkcWVxZPFl+WQJZQlkiWWJZEllSWTJZclkKWUpZKllqWRpZWlk6WXpZBllGWSZZZlkWWVZZNll2WQ5ZT5iHzlHnJvGU+Ml+Zn8xfFiALlOWS5ZblkeWV5ZPllxWQFZQVkhWWFZEVlRWTFZeVkJWUlZKVlpWRlZWVk5WXVZBVlFWSVZZVkVWVVZNVl9WQ1ZTVktWW1ZHVldWT1Zc1kDWUBcmCZSGyUFkjWWNZE1lTWTNZc1kLWUtZK1lrWRtZW1k7WXtZB1lHWSdZZ1kXWVdZN1l3WQ9ZT1kvWW9ZH1lfWT9Zf9kA2UDZINlg2RDZUNkw2XDZCNlI2SjZaNkY2VjZONl42QTZRNkk2WTZFNlU2TTZdNkM2UzZLNls2RzZXNk82XzZAtlC2SLZYtkS2VLZMtly2QrZStkq2WrZGtla2TrZetkG2UbZJtlm2RbZVtk22XbZDtlO2S7Zbtke2V7ZPtl+2QHZQdkh2WHZEdlR2THZcdkJ2UnZKdlp2RnZWdk52XnZBdlF2SXZZdkV2VXZNdl12Q3ZTdkt2W3ZHdld2T3ZfdkD2UPZI9lj2RPZU9kz2XPZC9lL2SvZa9kb2VvZO9l72QfZR9kn2WfZF9lX2TfZd9kP2U/ZL9lvmfNf+F1lbs7X7mXusvCyCLKIskiyyLIosqiyaLLoshiymLJYstiyOLK4sniy+LIEsoSyRLLEsiSypLJksuSyFLKUslSy1LI0srSydLL0sgyyjLJMssyyLLKssmyy7LIcspwyD5mnzEvmLfOR+cr8ZP6yAFmgLJcstyyPLK8snyy/83UaWUFZIVlhWRFZUVkxWXFZCVlJWSlZaVkZWVlZOVl5WQVZRVklWWVZFZnzuu/O64xXlzmvo+y8bq/zOrHO65I6r4PpvO6i8zp/zuvKOa9j5rxulvM6Tc7rAjmvQ+O87onzOhvO6zo4ryPgPLfeeU6681xu5znQznOHnefcOl+Xdr5u5XxdMrXLnzfn6zrO15+crwk6z4d1nkfqPP/Sed6i83w/53lyzvPLnOdlOc9ncp4H5Dx/xnneifN8Ded5Ds7zA5xntjrPCHWeSek8A9F55p7zjDfnmWLOM6ycZyY5z+hxngnjPIPEeeaF84wF53/T//ctvMt/ffNo13NN6ov5WuP3RQj7trZb1Gg+Ox/Xxh+L+H/4MeefIf93P5Y27Mean8pWIWJI1xN/v9817NvI//g2Pvy482lR4O95/92b59/3H0/n/XtEdPmvb/Gh4/3j5+kGP1aAdIa/7y9c2Lf/K3e3f/zY339tpH+cz5V/Ps9/niXc/+I/6+9b3LBv48H3/f31/G8lUw8adqIDAA==","debug_symbols":"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","file_map":{"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\n#[deprecated(\"This functions is deprecated in favour of external verification libraries. To verify Barretenberg proofs, it's recommended to use the library https://github.com/AztecProtocol/aztec-packages/tree/next/barretenberg/noir/bb_proof_verification\")]\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\n/// Asserts the validity of the provided proof and public inputs against the provided verification key and hash.\n///\n/// The ACVM cannot determine whether the provided proof is valid during execution as this requires knowledge of\n/// the backend against which the program is being proven. However if an invalid proof if submitted, the program may\n/// fail to prove or the backend may generate a proof which will subsequently fail to verify.\n///\n/// # Important Note\n///\n/// If you are not developing your own backend such as [Barretenberg](https://github.com/AztecProtocol/barretenberg)\n/// you probably shouldn't need to interact with this function directly. It's easier and safer to use a verification\n/// library which is published by the developers of the backend which will document or enforce any safety requirements.\n///\n/// If you use this directly, you're liable to introduce underconstrainedness bugs and *your circuit will be insecure*.\n///\n/// # Arguments\n/// - verification_key: The verification key of the circuit to be verified.\n/// - proof: The proof to be verified.\n/// - public_inputs: The public inputs associated with `proof`\n/// - key_hash: The hash of `verification_key` of the form expected by the backend.\n/// - proof_type: An identifier for the proving scheme used to generate the proof to be verified. This allows\n///               for a single backend to support verifying multiple proving schemes.\n///\n/// # Constraining `key_hash`\n///\n/// The Noir compiler does not by itself constrain that `key_hash` is a valid hash of `verification_key`.\n/// This is because different backends may differ in how they hash their verification keys.\n/// It is then the responsibility of either the noir developer (by explicitly hashing the verification key\n/// in the correct manner) or by the proving system itself internally asserting the correctness of `key_hash`.\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n","path":"std/lib.nr"},"59":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/calummoore/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"62":{"source":"use dep::std;\nuse poseidon::poseidon2;\n\nglobal AGG_UTXO_VERIFICATION_KEY_HASH: Field =\n    17312275849526493518721480386830253666706187309474064656261199404280431862138;\n\nstruct UtxoAggProof {\n    proof: [Field; 508],\n    old_root: Field,\n    new_root: Field,\n    commit_hash: Field,\n}\n\nfn main(\n    verification_key: [Field; 115],\n    verification_key_hash: Field,\n    utxo_agg_proofs: [UtxoAggProof; 2],\n    old_root: pub Field,\n    new_root: pub Field,\n    commit_hash: pub Field,\n    // 6 proofs, 6 per proof\n    messages: pub [Field; 30],\n) {\n    // Hardcode verification_key_hash for agg_utxo proof\n    assert(verification_key_hash == AGG_UTXO_VERIFICATION_KEY_HASH, \"only agg_utxo proof allowed\");\n\n    let mut root = old_root;\n    let mut first_public_inputs: [Field; 18] = [0; 18];\n\n    for i in 0..2 {\n        let proof = utxo_agg_proofs[i];\n        let public_inputs = [\n            messages[15 * i],\n            messages[15 * i + 1],\n            messages[15 * i + 2],\n            messages[15 * i + 3],\n            messages[15 * i + 4],\n            messages[15 * i + 5],\n            messages[15 * i + 6],\n            messages[15 * i + 7],\n            messages[15 * i + 8],\n            messages[15 * i + 9],\n            messages[15 * i + 10],\n            messages[15 * i + 11],\n            messages[15 * i + 12],\n            messages[15 * i + 13],\n            messages[15 * i + 14],\n            proof.old_root,\n            proof.new_root,\n            proof.commit_hash,\n        ];\n\n        if i == 0 {\n            first_public_inputs = public_inputs;\n        }\n\n        std::verify_proof_with_type(\n            verification_key,\n            if proof.old_root != 0 {\n                proof.proof\n            } else {\n                utxo_agg_proofs[0].proof\n            },\n            if proof.old_root != 0 {\n                public_inputs\n            } else {\n                first_public_inputs\n            },\n            verification_key_hash,\n            7,\n        );\n\n        if proof.old_root != 0 {\n            assert(proof.old_root == root, \"proof old_root must match previous root\");\n            root = proof.new_root;\n        }\n    }\n\n    assert(\n        commit_hash\n            == poseidon2::Poseidon2::hash(\n                [utxo_agg_proofs[0].commit_hash, utxo_agg_proofs[1].commit_hash],\n                2,\n            ),\n    );\n    assert(new_root == root, \"Roots must match\");\n}\n","path":"/Users/calummoore/conductor/repo/zk-rollup/calummoore-petra/noir/agg_agg/src/main.nr"}},"names":["main"],"brillig_names":["directive_invert"]}