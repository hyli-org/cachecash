use std::path::Path;

use anyhow::{Context, Result, anyhow};
use hyli_verifiers::noir_utils;
use sdk::{HyliOutput, ProgramId, ProofData, ProofTransaction, Verifier};

use crate::init::ContractDeployment;

/// Bundle of artifacts needed to submit (and optionally verify) a Noir proof.
#[derive(Debug, Clone)]
pub struct NoirProofArtifacts {
    /// Proof data generated by `bb prove` (concatenated proof + public inputs).
    pub proof: Vec<u8>,
    /// Program identifier (verifying key).
    pub program_id: ProgramId,
}

impl NoirProofArtifacts {
    /// Load artifacts from files produced by Noir tooling.
    pub fn from_files<P: AsRef<Path>>(proof_path: P, program_id_path: P) -> Result<Self> {
        let proof = std::fs::read(&proof_path).context("reading Noir proof file")?;
        let vk = std::fs::read(&program_id_path).context("reading Noir verifying key file")?;
        Ok(Self {
            proof,
            program_id: ProgramId(vk),
        })
    }
}

/// Helper to verify Noir proofs locally before sending them to the node.
///
/// Noir proofs embed the public inputs; we use the Hyli verification helpers to extract
/// the resulting [`HyliOutput`] (UTXO commitments, etc.) which can be returned to callers.
#[derive(Clone)]
pub struct NoirProver {
    verifier: Verifier,
    verify_locally: bool,
}

impl NoirProver {
    /// Create a new prover instance.
    pub fn new(verify_locally: bool) -> Self {
        Self {
            verifier: Verifier(sdk::verifiers::NOIR.to_string()),
            verify_locally,
        }
    }

    /// Create a [`ProofTransaction`] for the provided artifacts.
    ///
    /// When `verify_locally` is enabled, the proof is checked using the Noir verifier shipped
    /// with the Hyli toolchain before returning the transaction. The corresponding
    /// [`HyliOutput`] values are returned for convenience.
    pub fn build_proof_transaction(
        &self,
        contract: &ContractDeployment,
        artifacts: NoirProofArtifacts,
    ) -> Result<(ProofTransaction, Vec<HyliOutput>)> {
        let proof_data = ProofData(artifacts.proof.clone());

        // let outputs = if self.verify_locally {
        //     noir::verify(&proof_data, &artifacts.program_id)
        //         .context("verifying Noir proof locally")?
        // } else {
        // For callers that skip verification we still expose decoded outputs so the API response
        // remains consistent.

        let (public_inputs, _) =
            noir_utils::split_public_inputs(&proof_data.0, &artifacts.program_id.0)
                .ok_or_else(|| anyhow!("failed to split Noir public inputs from proof"))?;

        let outputs = vec![
            noir_utils::parse_noir_output(public_inputs)
                .context("parsing Noir public inputs into HyliOutput")?,
        ];
        // };

        let proof_tx = ProofTransaction {
            contract_name: contract.contract_name.clone(),
            program_id: artifacts.program_id,
            verifier: self.verifier.clone(),
            proof: proof_data,
        };

        Ok((proof_tx, outputs))
    }
}
